<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源代码 on 呦呦鹿鸣</title>
    <link>//localhost:1313/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/</link>
    <description>Recent content in 源代码 on 呦呦鹿鸣</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 29 Mar 2023 23:30:00 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go的结构体标签与反射</title>
      <link>//localhost:1313/post/golang/tag-and-reflect/</link>
      <pubDate>Wed, 29 Mar 2023 23:30:00 +0800</pubDate>
      <guid>//localhost:1313/post/golang/tag-and-reflect/</guid>
      <description>&lt;h2 id=&#34;一结构体标签&#34;&gt;一、结构体标签&#xA;&lt;a class=&#34;header-anchor&#34; href=&#34;#%e4%b8%80%e7%bb%93%e6%9e%84%e4%bd%93%e6%a0%87%e7%ad%be&#34;&gt;&lt;/a&gt;&#xA;&lt;/h2&gt;&lt;p&gt;结构体标签是附加在结构体字段上的小块元数据字符串，格式为 &lt;code&gt;key:&amp;quot;value&amp;quot;&lt;/code&gt;，其中 &lt;code&gt;key&lt;/code&gt; 是标签名，&lt;code&gt;value&lt;/code&gt; 是标签的值。一个字段可以有多个标签，标签之间用空格分隔。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的heap和源码分析</title>
      <link>//localhost:1313/post/golang/heap-sourcecode/</link>
      <pubDate>Sat, 04 Mar 2023 21:30:00 +0800</pubDate>
      <guid>//localhost:1313/post/golang/heap-sourcecode/</guid>
      <description>&lt;p&gt;之前用Go实现延时队列，我使用了Go标准库中的&lt;code&gt;container/heap&lt;/code&gt;接口来构建一个优先队列。为什么Go的&lt;code&gt;container/heap&lt;/code&gt;接口可以实现一个优先队列呢？&lt;/p&gt;&#xA;&lt;p&gt;这是因为Go的&lt;code&gt;container/heap&lt;/code&gt;定义了一套完整的方法，使得任何实现了这些方法的数据结构都能够作为堆来使用。优先队列是堆的一种应用，它允许快速访问最高（或最低）优先级的元素。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的WaitGroup源码分析</title>
      <link>//localhost:1313/post/golang/waitgroup-sourcecode/</link>
      <pubDate>Fri, 01 Apr 2022 09:00:20 +0800</pubDate>
      <guid>//localhost:1313/post/golang/waitgroup-sourcecode/</guid>
      <description>&lt;p&gt;&lt;code&gt;WaitGroup&lt;/code&gt; 是开发中经常用到的并发控制手段，其源代码在 &lt;code&gt;src/sync/waitgroup.go&lt;/code&gt; 文件中，定义了 1 个结构体和 4 个方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;WaitGroup{}&lt;/code&gt;&lt;/strong&gt;：结构体。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;state()&lt;/code&gt;&lt;/strong&gt;：内部方法，在 &lt;code&gt;Add()&lt;/code&gt;、&lt;code&gt;Wait()&lt;/code&gt; 中调用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Add()&lt;/code&gt;&lt;/strong&gt;：添加任务数、改变任务数。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Done()&lt;/code&gt;&lt;/strong&gt;：完成任务，其实就是 &lt;code&gt;Add(-1)&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Wait()&lt;/code&gt;&lt;/strong&gt;：阻塞等待所有任务的完成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以下源代码基于 &lt;code&gt;Go 1.17.5&lt;/code&gt; 版本，有删减。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的Channel发送和接收</title>
      <link>//localhost:1313/post/golang/channel/</link>
      <pubDate>Tue, 24 Aug 2021 01:46:00 +0800</pubDate>
      <guid>//localhost:1313/post/golang/channel/</guid>
      <description>&lt;p&gt;先来看一道面试题：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;对已经关闭的 chan 进行读写，会怎么样？为什么？&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上一篇学习 Go 协程的文章中，知道 go 关键字可以用来开启一个 goroutine 进行任务处理，但多个任务之间如果需要通信，就需要用到通道（channel）了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的Waitgroup和锁</title>
      <link>//localhost:1313/post/golang/waitgroup/</link>
      <pubDate>Tue, 18 May 2021 00:13:00 +0800</pubDate>
      <guid>//localhost:1313/post/golang/waitgroup/</guid>
      <description>&lt;p&gt;学 Go 的时候知道 Go 语言支持并发，最简单的方法是通过 go 关键字开启 goroutine 即可。可在工作中，用的是 sync 包的 WaitGroup，然而这样还不够，当多个 goroutine 同时访问一个变量时，还要考虑如何保证这些 goroutine 之间不会相互影响，这就又使用到了 sync 的 Mutex。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
