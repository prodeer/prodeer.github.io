<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源代码 on 呦呦鹿鸣</title><link>//localhost:1313/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/</link><description>Recent content in 源代码 on 呦呦鹿鸣</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 30 Dec 2024 19:30:00 +0800</lastBuildDate><atom:link href="//localhost:1313/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/rss.xml" rel="self" type="application/rss+xml"/><item><title>Golang的list和源码分析</title><link>//localhost:1313/post/golang/list-sourcecode/</link><pubDate>Mon, 30 Dec 2024 19:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/list-sourcecode/</guid><description>&lt;p>刷力扣时，有这样一道题，要求&lt;strong>设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构&lt;/strong>，实现这道题用到了Go 官方库提供的&lt;code>container/list&lt;/code>包中的List（双向链表）。&lt;/p></description></item><item><title>Golang的channel和源码分析</title><link>//localhost:1313/post/golang/channel-sourcecode/</link><pubDate>Sat, 21 Dec 2024 09:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/channel-sourcecode/</guid><description>&lt;p>&lt;code>channel&lt;/code> 的底层结构是一个复杂的并发数据结构，包含了缓冲区、等待队列、互斥锁等组件，用于实现&lt;code>goroutine&lt;/code>之间的安全通信和同步。&lt;/p>
&lt;p>Go 语言中的 channel 底层是通过 &lt;code>hchan&lt;/code> 结构体实现的，&lt;code>hchan&lt;/code> 结构体的定义和相关操作都位于 &lt;code>runtime/chan.go&lt;/code> 文件中，以下源代码基于 go1.23.3 版本，有删减。&lt;/p></description></item><item><title>Golang的结构体标签与反射</title><link>//localhost:1313/post/golang/tag-and-reflect/</link><pubDate>Wed, 29 Mar 2023 23:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/tag-and-reflect/</guid><description>&lt;h2 id="一结构体标签">一、结构体标签
&lt;a class="header-anchor" href="#%e4%b8%80%e7%bb%93%e6%9e%84%e4%bd%93%e6%a0%87%e7%ad%be">&lt;/a>
&lt;/h2>&lt;p>结构体标签是附加在结构体字段上的小块元数据字符串，格式为 &lt;code>key:&amp;quot;value&amp;quot;&lt;/code>，其中 &lt;code>key&lt;/code> 是标签名，&lt;code>value&lt;/code> 是标签的值。一个字段可以有多个标签，标签之间用空格分隔。&lt;/p></description></item><item><title>Golang的heap和源码分析</title><link>//localhost:1313/post/golang/heap-sourcecode/</link><pubDate>Sat, 04 Mar 2023 21:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/heap-sourcecode/</guid><description>&lt;p>之前用Go实现延时队列，我使用了Go标准库中的&lt;code>container/heap&lt;/code>接口来构建一个优先队列。为什么Go的&lt;code>container/heap&lt;/code>接口可以实现一个优先队列呢？&lt;/p>
&lt;p>这是因为Go的&lt;code>container/heap&lt;/code>定义了一套完整的方法，使得任何实现了这些方法的数据结构都能够作为堆来使用。优先队列是堆的一种应用，它允许快速访问最高（或最低）优先级的元素。&lt;/p></description></item><item><title>Golang的WaitGroup源码分析</title><link>//localhost:1313/post/golang/waitgroup-sourcecode/</link><pubDate>Fri, 01 Apr 2022 09:00:20 +0800</pubDate><guid>//localhost:1313/post/golang/waitgroup-sourcecode/</guid><description>&lt;p>&lt;code>WaitGroup&lt;/code> 是开发中经常用到的并发控制手段，其源代码在 &lt;code>src/sync/waitgroup.go&lt;/code> 文件中，定义了 1 个结构体和 4 个方法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>WaitGroup{}&lt;/code>&lt;/strong>：结构体。&lt;/li>
&lt;li>&lt;strong>&lt;code>state()&lt;/code>&lt;/strong>：内部方法，在 &lt;code>Add()&lt;/code>、&lt;code>Wait()&lt;/code> 中调用。&lt;/li>
&lt;li>&lt;strong>&lt;code>Add()&lt;/code>&lt;/strong>：添加任务数、改变任务数。&lt;/li>
&lt;li>&lt;strong>&lt;code>Done()&lt;/code>&lt;/strong>：完成任务，其实就是 &lt;code>Add(-1)&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>Wait()&lt;/code>&lt;/strong>：阻塞等待所有任务的完成。&lt;/li>
&lt;/ul>
&lt;p>以下源代码基于 &lt;code>Go 1.17.5&lt;/code> 版本，有删减。&lt;/p></description></item><item><title>Golang的Channel发送和接收</title><link>//localhost:1313/post/golang/channel/</link><pubDate>Tue, 24 Aug 2021 01:46:00 +0800</pubDate><guid>//localhost:1313/post/golang/channel/</guid><description>&lt;p>先来看一道面试题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>对已经关闭的 chan 进行读写，会怎么样？为什么？
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上一篇学习 Go 协程的文章中，知道 go 关键字可以用来开启一个 goroutine 进行任务处理，但多个任务之间如果需要通信，就需要用到通道（channel）了。&lt;/p></description></item><item><title>Golang的Waitgroup和锁</title><link>//localhost:1313/post/golang/waitgroup/</link><pubDate>Tue, 18 May 2021 00:13:00 +0800</pubDate><guid>//localhost:1313/post/golang/waitgroup/</guid><description>&lt;p>学 Go 的时候知道 Go 语言支持并发，最简单的方法是通过 go 关键字开启 goroutine 即可。可在工作中，用的是 sync 包的 WaitGroup，然而这样还不够，当多个 goroutine 同时访问一个变量时，还要考虑如何保证这些 goroutine 之间不会相互影响，这就又使用到了 sync 的 Mutex。&lt;/p></description></item></channel></rss>