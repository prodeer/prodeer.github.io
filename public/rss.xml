<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>呦呦鹿鸣</title><link>//localhost:1313/</link><description>Recent content on 呦呦鹿鸣</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Nov 2024 13:44:11 +0800</lastBuildDate><atom:link href="//localhost:1313/rss.xml" rel="self" type="application/rss+xml"/><item><title>关于我</title><link>//localhost:1313/about/</link><pubDate>Mon, 25 Nov 2024 13:44:11 +0800</pubDate><guid>//localhost:1313/about/</guid><description>&lt;p>2015 年毕业后一直从事后端开发工作， 写过 PHP，会一点 Java，现今主要从事 Golang 开发，目标是一个又一个的十年之约。&lt;/p>
&lt;p>先后就业于教育、出行、车联网行业，世界在变，我们也要变，跟上节奏，一起向前。&lt;/p></description></item><item><title>构建分布式任务调度系统（二）：系统设计与实现</title><link>//localhost:1313/post/dts/system-design/</link><pubDate>Sun, 16 Apr 2023 22:10:00 +0800</pubDate><guid>//localhost:1313/post/dts/system-design/</guid><description>&lt;h2 id="一什么是分布式任务调度">一、什么是分布式任务调度
&lt;a class="header-anchor" href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6">&lt;/a>
&lt;/h2>&lt;p>任务调度是指基于&lt;strong>给定的时间点&lt;/strong>，&lt;strong>给定的时间间隔&lt;/strong>或者给定执行次数自动的&lt;strong>执行任务&lt;/strong>。分布式调度系统用于处理需要在多个服务器或计算节点上并行执行的复杂计算任务，提高任务调度的效率、可靠性和可扩展性。&lt;/p></description></item><item><title>构建分布式任务调度系统（一）：时间轮</title><link>//localhost:1313/post/dts/timing-wheel/</link><pubDate>Sat, 15 Apr 2023 12:30:00 +0800</pubDate><guid>//localhost:1313/post/dts/timing-wheel/</guid><description>&lt;p>时间轮（Timing Wheel）是一种高效的数据结构，用于管理定时任务或事件。在分布式任务调度系统等场景中经常可以看到时间轮的实现，以实现对大量定时任务的高效调度。&lt;/p></description></item><item><title>Go的结构体标签与反射</title><link>//localhost:1313/post/golang/tag-and-reflect/</link><pubDate>Wed, 29 Mar 2023 23:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/tag-and-reflect/</guid><description>&lt;h2 id="一结构体标签">一、结构体标签
&lt;a class="header-anchor" href="#%e4%b8%80%e7%bb%93%e6%9e%84%e4%bd%93%e6%a0%87%e7%ad%be">&lt;/a>
&lt;/h2>&lt;p>结构体标签是附加在结构体字段上的小块元数据字符串，格式为 &lt;code>key:&amp;quot;value&amp;quot;&lt;/code>，其中 &lt;code>key&lt;/code> 是标签名，&lt;code>value&lt;/code> 是标签的值。一个字段可以有多个标签，标签之间用空格分隔。&lt;/p></description></item><item><title>Go的heap和源码分析</title><link>//localhost:1313/post/golang/heap-sourcecode/</link><pubDate>Sat, 04 Mar 2023 21:30:00 +0800</pubDate><guid>//localhost:1313/post/golang/heap-sourcecode/</guid><description>&lt;p>之前用Go实现延时队列，我使用了Go标准库中的&lt;code>container/heap&lt;/code>接口来构建一个优先队列。为什么Go的&lt;code>container/heap&lt;/code>接口可以实现一个优先队列呢？&lt;/p>
&lt;p>这是因为Go的&lt;code>container/heap&lt;/code>定义了一套完整的方法，使得任何实现了这些方法的数据结构都能够作为堆来使用。优先队列是堆的一种应用，它允许快速访问最高（或最低）优先级的元素。&lt;/p></description></item><item><title>Golang实现一个基于本地存储的延时队列</title><link>//localhost:1313/post/mq/delayed-queue/</link><pubDate>Fri, 17 Feb 2023 21:20:10 +0800</pubDate><guid>//localhost:1313/post/mq/delayed-queue/</guid><description>&lt;h2 id="一什么是延迟队列">一、什么是延迟队列
&lt;a class="header-anchor" href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97">&lt;/a>
&lt;/h2>&lt;p>延迟队列是一种特殊的队列，其核心特点是队列中的消息或任务会被延迟一定时间后才能被消费或执行。这种队列广泛应用于需要延迟处理的场景，比如订单超时未支付自动取消、用户注册后一段时间未登录发送提醒等。&lt;/p></description></item><item><title>任务系统的设计</title><link>//localhost:1313/post/system/task-system/</link><pubDate>Sat, 28 Jan 2023 10:37:58 +0800</pubDate><guid>//localhost:1313/post/system/task-system/</guid><description>&lt;h2 id="一背景">一、背景
&lt;a class="header-anchor" href="#%e4%b8%80%e8%83%8c%e6%99%af">&lt;/a>
&lt;/h2>&lt;p>由于业务中引入了小队、队长、导师、服务经理等角色，如何合理地安排和考核几千名司服和上万名队长的工作，就成为了不小的挑战，任务系统应运而生。&lt;/p>
&lt;p>任务系统通过接入各类事件，在不同的任务场景下将任务分配给不同的角色——司服、队长、导师等。一旦任务完成，系统通过消息队列（MQ）机制及时通知下游系统。在某些特定场景下，还会推送质检任务，并根据结果发放相应的奖励，以此激励团队成员，提高整体工作效率和质量。&lt;/p></description></item><item><title>Go的弱引用</title><link>//localhost:1313/post/golang/weak-reference/</link><pubDate>Mon, 09 Jan 2023 00:13:00 +0800</pubDate><guid>//localhost:1313/post/golang/weak-reference/</guid><description>&lt;p>在学习观察者模式的时候，看到观察者模式的实现方式之一有弱引用，所以专门学习了一下这个知识点。&lt;/p></description></item><item><title>Golang实现观察者模式（Observer Pattern）</title><link>//localhost:1313/post/desiginpattern/observer-pattern/</link><pubDate>Sun, 08 Jan 2023 22:52:01 +0800</pubDate><guid>//localhost:1313/post/desiginpattern/observer-pattern/</guid><description>&lt;p>观察者模式是一种行为型设计模式，它定义了对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都会得到通知并自动更新。这种模式也被称为发布-订阅模式、模型-视图模式、源-监听器模式。&lt;/p></description></item><item><title>13种缓存模式汇总</title><link>//localhost:1313/post/cache/caching-patterns/</link><pubDate>Tue, 03 Jan 2023 18:10:45 +0800</pubDate><guid>//localhost:1313/post/cache/caching-patterns/</guid><description>&lt;p>学习和总结了13种缓存模式的优缺点、应用场景和工作流程。（汇总见底部的思维导图）&lt;/p></description></item><item><title>认识MQTT（三）：MQTT在业务中的应用</title><link>//localhost:1313/post/mq/use-mqtt/</link><pubDate>Sat, 31 Dec 2022 17:10:20 +0800</pubDate><guid>//localhost:1313/post/mq/use-mqtt/</guid><description>&lt;p>我们的系统连接着车辆和用户两端，车辆的个性化配置数据上报到云端，又或者用户登录后的账户信息下发给车端，车辆与云端之间的数据传输都是通过MQTT网关来实现的。&lt;/p></description></item><item><title>Golang实现工厂模式（Factory Pattern）</title><link>//localhost:1313/post/desiginpattern/factory-pattern/</link><pubDate>Wed, 21 Dec 2022 12:52:01 +0800</pubDate><guid>//localhost:1313/post/desiginpattern/factory-pattern/</guid><description>&lt;p>工厂模式（Factory Pattern）是一种创建型设计模式，用于处理对象的创建。在工厂模式中，创建对象的任务被推迟到子类中，这些子类被称为工厂方法。这种模式的主要目的是将对象的创建和使用分离，使得在不知道具体类的情况下也能创建对象。&lt;/p></description></item><item><title>认识MQTT（二）：RabbitMQ支持MQTT</title><link>//localhost:1313/post/mq/rabbitmq-support-mqtt/</link><pubDate>Thu, 15 Dec 2022 16:00:20 +0800</pubDate><guid>//localhost:1313/post/mq/rabbitmq-support-mqtt/</guid><description>&lt;p>&lt;code>RabbitMQ&lt;/code>是通过插件的形式支持&lt;code>MQTT&lt;/code>协议的，使用时，需要在RabbitMQ集群上启用&lt;code>rabbitmq_mqtt&lt;/code>插件。&lt;/p></description></item><item><title>认识MQTT（一）：MQTT是什么</title><link>//localhost:1313/post/mq/mqtt-introduction/</link><pubDate>Wed, 07 Dec 2022 21:00:20 +0800</pubDate><guid>//localhost:1313/post/mq/mqtt-introduction/</guid><description>&lt;p>和车打交道后，接触到了&lt;code>MQTT&lt;/code>，第一次听到这个词时，我还疑心自己是不是听错了，问Leader是不是&lt;code>MQ&lt;/code>，得到了“不是”的答复，遂有此文，总结一下我所了解的&lt;code>MQTT&lt;/code>。&lt;/p></description></item><item><title>用Golang实现一个消息队列</title><link>//localhost:1313/post/golang/implement-queue/</link><pubDate>Sun, 04 Dec 2022 20:00:20 +0800</pubDate><guid>//localhost:1313/post/golang/implement-queue/</guid><description>&lt;p>Go的&lt;code>channel&lt;/code>是并发编程中的一种同步通信机制，天然支持并发请求，因此可以用来实现消息队列。这里实现一个能够处理并发请求的消息队列。&lt;/p></description></item><item><title>Golang实现单例模式（Singleton Pattern）</title><link>//localhost:1313/post/desiginpattern/singleton-pattern/</link><pubDate>Wed, 30 Nov 2022 14:52:01 +0800</pubDate><guid>//localhost:1313/post/desiginpattern/singleton-pattern/</guid><description>&lt;p>单例模式（Singleton Pattern）是一种常用的软件设计模式，其核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。这种模式在很多场景下都非常有用，特别是在需要控制资源访问的情况下。&lt;/p></description></item><item><title>车辆激活（扫码激活）的实现</title><link>//localhost:1313/post/system/vehicle-active/</link><pubDate>Mon, 28 Nov 2022 20:37:58 +0800</pubDate><guid>//localhost:1313/post/system/vehicle-active/</guid><description>&lt;h3 id="一业务场景">一、业务场景
&lt;a class="header-anchor" href="#%e4%b8%80%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af">&lt;/a>
&lt;/h3>&lt;p>车辆激活是在车端大屏幕上生成一个二维码，车主使用App进行扫码，点击“确认激活”，车端收到指令后，由相应的模块（一般是CDC）进行本地激活。&lt;/p></description></item><item><title>Go的定时器之Time.Ticker</title><link>//localhost:1313/post/golang/time-ticker/</link><pubDate>Fri, 22 Apr 2022 22:47:20 +0800</pubDate><guid>//localhost:1313/post/golang/time-ticker/</guid><description>&lt;h3 id="一引子">一、引子
&lt;a class="header-anchor" href="#%e4%b8%80%e5%bc%95%e5%ad%90">&lt;/a>
&lt;/h3>&lt;p>面试官问了一道题：每秒钟调用一次proc并保证程序不退出。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">proc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;ok&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这道题考察的知识点主要有：&lt;/p>
&lt;ol>
&lt;li>定时执行任务&lt;/li>
&lt;li>捕获 &lt;code>panic&lt;/code> 错误&lt;/li>
&lt;/ol>
&lt;p>这里主要学习、了解 &lt;code>Time.Ticker&lt;/code> 的实现，其源代码基于 &lt;code>Go 1.17.9&lt;/code> 版本，主要在 &lt;code>src/time/tick.go&lt;/code> 文件中，包含了一个结构体和四个函数。&lt;/p></description></item><item><title>Go的WaitGroup源码分析</title><link>//localhost:1313/post/golang/waitgroup-sourcecode/</link><pubDate>Fri, 01 Apr 2022 09:00:20 +0800</pubDate><guid>//localhost:1313/post/golang/waitgroup-sourcecode/</guid><description>&lt;p>&lt;code>WaitGroup&lt;/code> 是开发中经常用到的并发控制手段，其源代码在 &lt;code>src/sync/waitgroup.go&lt;/code> 文件中，定义了 1 个结构体和 4 个方法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>WaitGroup{}&lt;/code>&lt;/strong>：结构体。&lt;/li>
&lt;li>&lt;strong>&lt;code>state()&lt;/code>&lt;/strong>：内部方法，在 &lt;code>Add()&lt;/code>、&lt;code>Wait()&lt;/code> 中调用。&lt;/li>
&lt;li>&lt;strong>&lt;code>Add()&lt;/code>&lt;/strong>：添加任务数、改变任务数。&lt;/li>
&lt;li>&lt;strong>&lt;code>Done()&lt;/code>&lt;/strong>：完成任务，其实就是 &lt;code>Add(-1)&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>Wait()&lt;/code>&lt;/strong>：阻塞等待所有任务的完成。&lt;/li>
&lt;/ul>
&lt;p>以下源代码基于 &lt;code>Go 1.17.5&lt;/code> 版本，有删减。&lt;/p></description></item><item><title>Go的Select的用法</title><link>//localhost:1313/post/golang/select/</link><pubDate>Sun, 10 Oct 2021 23:52:00 +0800</pubDate><guid>//localhost:1313/post/golang/select/</guid><description>&lt;p>Go 的通道有两种操作方式，一种是带 range 子句的 for 语句，另一种则是 select 语句，它是专门为了操作通道而存在的。这里主要介绍 select 的用法。&lt;/p></description></item><item><title>Go的Channel发送和接收</title><link>//localhost:1313/post/golang/channel/</link><pubDate>Tue, 24 Aug 2021 01:46:00 +0800</pubDate><guid>//localhost:1313/post/golang/channel/</guid><description>&lt;p>先来看一道面试题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>对已经关闭的 chan 进行读写，会怎么样？为什么？
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上一篇学习 Go 协程的文章中，知道 go 关键字可以用来开启一个 goroutine 进行任务处理，但多个任务之间如果需要通信，就需要用到通道（channel）了。&lt;/p></description></item><item><title>Go的Waitgroup和锁</title><link>//localhost:1313/post/golang/waitgroup/</link><pubDate>Tue, 18 May 2021 00:13:00 +0800</pubDate><guid>//localhost:1313/post/golang/waitgroup/</guid><description>&lt;p>学 Go 的时候知道 Go 语言支持并发，最简单的方法是通过 go 关键字开启 goroutine 即可。可在工作中，用的是 sync 包的 WaitGroup，然而这样还不够，当多个 goroutine 同时访问一个变量时，还要考虑如何保证这些 goroutine 之间不会相互影响，这就又使用到了 sync 的 Mutex。&lt;/p></description></item><item><title>归档</title><link>//localhost:1313/archives/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//localhost:1313/archives/archives/</guid><description/></item></channel></rss>