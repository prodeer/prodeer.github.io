<!doctype html><html lang=zh-CN data-theme=light><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.139.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Golang的channel和源码分析"><meta itemprop=description content><meta name=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="//localhost:1313/imgs/liulu_avatar.png"><meta itemprop=keywords content="channel,源代码"><meta property="og:type" content="article"><meta property="og:title" content="Golang的channel和源码分析"><meta property="og:description" content><meta property="og:image" content="/imgs/liulu_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="//localhost:1313/post/golang/channel-sourcecode/"><meta property="og:site_name" content="呦呦鹿鸣"><meta property="og:locale" content="zh-CN"><meta property="article:author" content><meta property="article:published_time" content="2024-12-21 09:30:00 +0800 CST"><meta property="article:modified_time" content="2024-12-21 09:30:00 +0800 CST"><link type=text/css rel=stylesheet href=//localhost:1313/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=//localhost:1313/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=//localhost:1313/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet type=text/css href=/css/custom_style.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"channel-sourcecode","permalink":"//localhost:1313/post/golang/channel-sourcecode/","title":"Golang的channel和源码分析","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Golang的channel和源码分析 - 呦呦鹿鸣</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>呦呦鹿鸣</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>prodeer's Blog</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>26</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#一channel-的底层结构>一、channel 的底层结构</a><ul><li><a href=#11-hchan>1.1 hchan</a></li><li><a href=#12-waitq>1.2 waitq</a></li><li><a href=#13-sudog>1.3 sudog</a></li><li><a href=#14-hchan图解>1.4 hchan图解</a></li></ul></li><li><a href=#二channel-的操作>二、channel 的操作</a><ul><li><a href=#21-通道创建>2.1 通道创建</a></li><li><a href=#22-向通道发送数据>2.2 向通道发送数据</a></li><li><a href=#23-从通道接收数据>2.3 从通道接收数据</a></li><li><a href=#24-通道关闭>2.4 通道关闭</a></li></ul></li><li><a href=#三小结>三、小结</a><ul><li><a href=#31-有缓冲-channel-和无缓冲-channel-的对比>3.1 有缓冲 channel 和无缓冲 channel 的对比</a></li><li><a href=#32-对-nil--已关闭的有数据的-channel-进行读写和关闭操作>3.2 对 nil / 已关闭的/有数据的 channel 进行读写和关闭操作</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt src=/imgs/img-lazy-loading.gif data-src=/imgs/liulu_avatar.png><p class=site-author-name itemprop=name></p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>26</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/sunshineliulu title=https://www.cnblogs.com/sunshineliulu target=_blank>呦呦鹿鸣</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2021-05-18T00:13:00+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=58669></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=132></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2025-01-08T18:58:22+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/golang/channel-sourcecode/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/liulu_avatar.png"><meta itemprop=name content></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Golang的channel和源码分析"><meta itemprop=description content="channel 的底层结构是一个复杂的并发数据结构，包含了缓冲区、等待队列、互斥锁等组件，用于实现goroutine之间的安全通信和同步。
Go 语言中的 channel 底层是通过 hchan 结构体实现的，hchan 结构体的定义和相关操作都位于 runtime/chan.go 文件中，以下源代码基于 go1.23.3 版本，有删减。"></span><header class=post-header><h1 class=post-title itemprop="name headline">Golang的channel和源码分析</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-12-21 09:30:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-12-21 09:30:00 +0800 CST">2024-12-21
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/golang itemprop=url rel=index><span itemprop=name>Golang</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4921</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/golang/channel-sourcecode/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><code>channel</code> 的底层结构是一个复杂的并发数据结构，包含了缓冲区、等待队列、互斥锁等组件，用于实现<code>goroutine</code>之间的安全通信和同步。</p><p>Go 语言中的 channel 底层是通过 <code>hchan</code> 结构体实现的，<code>hchan</code> 结构体的定义和相关操作都位于 <code>runtime/chan.go</code> 文件中，以下源代码基于 go1.23.3 版本，有删减。</p><h3 id=一channel-的底层结构>一、channel 的底层结构
<a class=header-anchor href=#%e4%b8%80channel-%e7%9a%84%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84></a></h3><p>channel涉及到的核心数据结构包含3个，<code>hchan</code>、<code>waitq</code>、<code>sudog</code>。</p><h4 id=11-hchan>1.1 hchan
<a class=header-anchor href=#11-hchan></a></h4><p>以下是 <code>hchan</code> 结构体的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// 当前 channel 中的数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// channel 缓冲区的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 指向缓冲区的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>         <span style=color:#75715e>// channel 中元素的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span>         <span style=color:#75715e>// channel 是否关闭的标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>         <span style=color:#75715e>// channel 中元素的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// 发送操作的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// 接收操作的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>          <span style=color:#75715e>// 接收操作的等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>          <span style=color:#75715e>// 发送操作的等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lock</span>     <span style=color:#a6e22e>mutex</span>          <span style=color:#75715e>// 互斥锁，用于保护 channel 的操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>hchan</code>结构体的主要组成部分有四个：</p><ul><li><strong>buf</strong>：用来保存goroutine之间传递数据的循环链表。</li><li><strong>sendx</strong>和<strong>recvx</strong>：用来记录此循环链表当前发送或接收数据的下标值。</li><li><strong>sendq</strong> 和 <strong>recvq</strong>：用于保存向该chan发送和从该chan接收数据的goroutine的队列。</li><li><strong>lock</strong>：保证channel写入和读取数据时线程安全的锁。</li></ul><h4 id=12-waitq>1.2 waitq
<a class=header-anchor href=#12-waitq></a></h4><p><code>waitq</code>是因读写 channel 而陷入阻塞的协程等待队列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>    <span style=color:#75715e>// 队列头部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>    <span style=color:#75715e>// 队列尾部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=13-sudog>1.3 sudog
<a class=header-anchor href=#13-sudog></a></h4><p><code>sudog</code>是协程等待队列的节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sudog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>                <span style=color:#75715e>// 等待send或recv的协程g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>         <span style=color:#75715e>// 等待队列下一个结点next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>         <span style=color:#75715e>// 等待队列前一个结点next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// data element (may point to stack)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>acquiretime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>releasetime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ticket</span>      <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isSelect</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>success</span> <span style=color:#66d9ef>bool</span>        <span style=color:#75715e>// 标记协程g被唤醒是因为数据传递(true)还是channel被关闭(false)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>waiters</span> <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>parent</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot binary tree
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>waitlink</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// g.waiting list or semaRoot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>waittail</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> <span style=color:#75715e>// channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=14-hchan图解>1.4 hchan图解
<a class=header-anchor href=#14-hchan%e5%9b%be%e8%a7%a3></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src="https://exknk14n7b.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI5MjgwMTk4ZjRiMGU1NDQ3ZWQxZDA1Y2UzODM3MDBfSVJuZDA2Rmxza1JLT3VNNXlUY1Zqbmg5N1ZiOUI0WHdfVG9rZW46RnJGdWJNQ2tzb01KRDJ4NHRvdmNNR0ZibnRkXzE3MzY4NjczODY6MTczNjg3MDk4Nl9WNA" alt></p><p><strong>环形缓冲区</strong></p><ul><li>如果 channel 是有缓冲的，<code>hchan</code> 中的 <code>buf</code> 字段会指向一个环形缓冲区（circular buffer），用于存储待发送或待接收的元素。</li><li><code>dataqsiz</code> 表示缓冲区的大小，<code>qcount</code> 表示当前缓冲区中的元素数量。</li><li><code>sendx</code> 和 <code>recvx</code> 分别表示发送和接收的索引，用于在环形缓冲区中定位下一个要发送或接收的元素。</li></ul><p><strong>等待队列</strong></p><p><strong>互斥锁</strong></p><p><code>lock</code> 是一个互斥锁，用于保护 channel 的并发访问，确保在同一时间只有一个 goroutine 可以修改 channel 的状态。</p><h3 id=二channel-的操作>二、channel 的操作
<a class=header-anchor href=#%e4%ba%8cchannel-%e7%9a%84%e6%93%8d%e4%bd%9c></a></h3><h4 id=21-通道创建>2.1 通道创建
<a class=header-anchor href=#21-%e9%80%9a%e9%81%93%e5%88%9b%e5%bb%ba></a></h4><ul><li>创建 channel 时，会根据 channel 的类型（有缓冲或无缓冲）分配相应的内存，并初始化 <code>hchan</code> 结构体。对于无缓冲 channel，缓冲区大小为 0，而对于有缓冲 <code>channel</code>，则会分配相应大小的缓冲区。</li><li>创建过程包括分配 <code>hchan</code> 结构体的内存、初始化互斥锁、设置缓冲区大小和元素类型等。</li></ul><p>源代码定义了一个 <code>makechan</code> 函数，该函数用于创建一个新的 channel。下面是对这段代码的逐行分析：</p><ol><li><strong>函数签名</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {}
</span></span></code></pre></div><p><code>makechan</code> 函数接收两个参数：</p><ol start=2><li><strong>元素大小检查</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Elem</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// compiler checks this but be safe.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Size_</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>16</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;makechan: invalid channel element type&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里获取了 channel 元素的类型信息，并检查元素大小是否超过了 1&#171;16（即 65536 字节）。如果超过，抛出异常，因为 Go 语言的 channel 不支持这么大的元素。</p><ol start=3><li><strong>对齐和大小检查</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>%</span><span style=color:#a6e22e>maxAlign</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Align_</span> &gt; <span style=color:#a6e22e>maxAlign</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;makechan: bad alignment&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>检查 <code>hchan</code> 结构体的大小是否满足最大对齐要求，以及元素的对齐要求是否超过了最大对齐要求。如果不满足，同样抛出异常。</p><ol start=4><li><strong>内存分配检查</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Size_</span>, uintptr(<span style=color:#a6e22e>size</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>hchanSize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;makechan: size out of range&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>计算所需的内存大小（元素大小乘以容量），并检查是否发生了溢出，或者所需内存加上 <code>hchan</code> 结构体的大小超过了最大分配限制，或者容量小于 0。如果这些检查失败，触发 panic。</p><ol start=5><li><strong>内存分配策略</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Queue or element size is zero.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Race detector uses this location for synchronization.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> !<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Pointers</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Elements do not contain pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Allocate hchan and buf in one call.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Elements contain pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>根据元素是否包含指针和所需内存大小，选择不同的内存分配策略：</p><ul><li>如果内存大小为 0（无缓冲 channel 或元素大小为 0），分配 <code>hchan</code> 结构体的内存，并设置 <code>buf</code> 为 <code>hchan</code> 结构体内部的 <code>raceaddr</code> 字段，用于竞态检测。</li><li>如果元素不包含指针，将 <code>hchan</code> 结构体和缓冲区一起分配。</li><li>如果元素包含指针，先分配 <code>hchan</code> 结构体，然后单独分配缓冲区的内存。</li></ul><p>channel 本身是引用类型，其创建全部调用的是 <code>mallocgc()</code>，在堆上开辟的内存空间，说明 channel 本身会被 GC 自动回收。</p><ol start=6><li><strong>初始化 <code>hchan</code></strong>结构体：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Size_</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankHchan</span>)
</span></span></code></pre></div><p>初始化 <code>hchan</code> 结构体的字段，包括元素大小、元素类型、缓冲区大小，并初始化互斥锁。</p><h4 id=22-向通道发送数据>2.2 向通道发送数据
<a class=header-anchor href=#22-%e5%90%91%e9%80%9a%e9%81%93%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae></a></h4><ul><li>如果 <code>channel</code> 的缓冲区未满，发送操作会将元素放入缓冲区并更新 <code>sendx</code> 和 <code>qcount</code>。</li><li>如果缓冲区已满，发送操作会将当前<code>goroutine</code>加入 <code>sendq</code> 队列并阻塞，直到有接收者接收数据。</li></ul><p>源代码定义了一个 <code>chansend</code> 函数，该函数用于向 channel 发送数据。下面是对这段代码的逐行分析：</p><ol><li><strong>函数签名</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {}
</span></span></code></pre></div><p><code>chansend</code> 函数接收四个参数：</p><ul><li><code>c</code> 是一个指向 <code>hchan</code> 的指针，表示要发送数据的 channel。</li><li><code>ep</code> 是一个 <code>unsafe.Pointer</code> 类型，指向要发送的数据。</li><li><code>block</code> 是一个布尔值，表示是否阻塞发送操作。</li><li><code>callerpc</code> 是调用者的程序计数器，用于调试和竞态检测。</li></ul><ol start=2><li><strong>检查 channel 是否为空</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceBlockForever</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 为空，并且 <code>block</code> 为 <code>false</code>，则返回 <code>false</code>。如果 <code>block</code> 为 <code>true</code>，则调用 <code>gopark</code> 函数使当前 goroutine 进入等待状态，并抛出异常（理论上不会执行到这里）。</p><ol start=3><li><strong>竞态检测</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>racereadpc</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>(), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>chansend</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果启用了竞态检测，记录当前 goroutine 的状态。</p><ol start=4><li><strong>快速路径</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>full</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不阻塞并且 channel 未关闭，但缓冲区已满，则返回 <code>false</code>。</p><ol start=5><li><strong>计时器</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果启用了阻塞分析，记录当前时间。</p><ol start=6><li><strong>加锁</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span></code></pre></div><p>加锁以保护 channel 的状态。</p><ol start=7><li><strong>检查 channel 是否关闭</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 已关闭，解锁并抛出异常。</p><ol start=8><li><strong>发送给等待的接收者</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果有等待的接收者，直接将数据发送给接收者，绕过缓冲区。</p><ol start=9><li><strong>缓冲区发送</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果缓冲区有空间，将数据放入缓冲区。</p><ol start=10><li><strong>非阻塞发送</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不阻塞并且缓冲区已满，解锁并返回 <code>false</code>。</p><ol start=11><li><strong>阻塞发送</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceBlockChanSend</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>KeepAlive</span>(<span style=color:#a6e22e>ep</span>)
</span></span></code></pre></div><p>如果阻塞，将当前 goroutine 加入发送队列，并调用 <code>gopark</code> 函数使当前 goroutine 进入等待状态。</p><ol start=12><li><strong>唤醒</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> !<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>closed</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>当有接收者接收数据时，唤醒发送者。检查 channel 是否关闭，并返回发送结果。</p><h4 id=23-从通道接收数据>2.3 从通道接收数据
<a class=header-anchor href=#23-%e4%bb%8e%e9%80%9a%e9%81%93%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae></a></h4><p>如果 <code>channel</code> 的缓冲区不为空，接收操作会从缓冲区中取出元素并更新 <code>recvx</code> 和 <code>qcount</code>。<br>如果缓冲区为空，接收操作会将当前<code>goroutine</code>加入 <code>recvq</code> 队列并阻塞，直到有发送者发送数据。<br>源代码实现了 <code>chanrecv</code> 函数，该函数用于从 channel 接收数据。下面是对这段代码的逐行分析：</p><ol><li><strong>函数签名</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>)
</span></span></code></pre></div><p><code>chanrecv</code> 函数接收三个参数：</p><ul><li><code>c</code> 是一个指向 <code>hchan</code> 的指针，表示要接收数据的 channel。</li><li><code>ep</code> 是一个 <code>unsafe.Pointer</code> 类型，指向接收数据的内存位置。</li><li><code>block</code> 是一个布尔值，表示是否阻塞接收操作。</li></ul><p>函数返回两个布尔值：<code>selected</code> 和 <code>received</code>，分别表示是否选择了该 channel 进行操作（在多路复用场景中）和是否成功接收到数据。</p><ol start=2><li><strong>检查 channel 是否为空</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanReceiveNilChan</span>, <span style=color:#a6e22e>traceBlockForever</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 为空，并且 <code>block</code> 为 <code>false</code>，则返回。如果 <code>block</code> 为 <code>true</code>，则调用 <code>gopark</code> 函数使当前 goroutine 进入等待状态，并抛出异常（理论上不会执行到这里）。</p><ol start=3><li><strong>检查 channel 的定时器</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>maybeRunChan</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 有定时器，检查并可能运行定时器。</p><ol start=4><li><strong>快速路径</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不阻塞并且 channel 为空，则检查 channel 是否关闭。如果关闭，检查缓冲区是否有数据。如果没有数据，则返回 <code>true, false</code>。</p><ol start=5><li><strong>计时器</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果启用了阻塞分析，记录当前时间。</p><ol start=6><li><strong>加锁</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span></code></pre></div><p>加锁以保护 channel 的状态。</p><ol start=7><li><strong>检查 channel 是否关闭</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 已关闭，检查缓冲区是否有数据。如果没有数据，则返回 <code>true, false</code>。</p><ol start=8><li><strong>从发送队列接收</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果有等待的发送者，直接从发送队列接收数据。</p><ol start=9><li><strong>从缓冲区接收</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果缓冲区有数据，从缓冲区接收数据。</p><ol start=10><li><strong>非阻塞接收</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不阻塞并且缓冲区为空，解锁并返回 <code>false, false</code>。</p><ol start=11><li><strong>阻塞接收</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blockTimerChan</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanReceive</span>, <span style=color:#a6e22e>traceBlockChanRecv</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unblockTimerChan</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>success</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>success</span>
</span></span></code></pre></div><p>如果阻塞，将当前 goroutine 加入接收队列，并调用 <code>gopark</code> 函数使当前 goroutine 进入等待状态。</p><ol start=12><li><strong>唤醒</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unblockTimerChan</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>success</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>success</span>
</span></span></code></pre></div><p>当有发送者发送数据时，唤醒接收者。检查接收是否成功，并返回结果。</p><h4 id=24-通道关闭>2.4 通道关闭
<a class=header-anchor href=#24-%e9%80%9a%e9%81%93%e5%85%b3%e9%97%ad></a></h4><ul><li>关闭 <code>channel</code> 会设置 <code>closed</code> 标志，并唤醒所有等待的<code>goroutine</code>（发送者和接收者）。</li><li>关闭后的 <code>channel</code> 不能再发送数据，但可以继续接收数据，直到缓冲区为空。</li></ul><p>源代码实现了 <code>closechan</code> 函数，该函数用于关闭一个 channel。关闭 channel 是一个重要的操作，它通知所有等待在该 channel 上的 goroutine， channel 已经关闭，不能再进行发送或接收操作。下面是对这段代码的逐行分析：</p><ol><li><strong>检查 Channel 是否为空</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of nil channel&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 为空，抛出异常，因为不能关闭一个空的 channel。</p><ol start=2><li><strong>加锁</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span></code></pre></div><p>获取 channel 的互斥锁，以确保对 channel 状态的修改是原子操作。</p><ol start=3><li><strong>检查 Channel 是否已关闭</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of closed channel&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 channel 已经关闭，解锁并抛出异常，因为不能重复关闭一个 channel。</p><ol start=4><li><strong>竞态检测</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>(), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>closechan</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>racerelease</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果启用了数据竞争检测，记录当前 goroutine 的状态，并标记 channel 的内存位置为“已释放”。</p><ol start=5><li><strong>标记 Channel 为已关闭</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> = <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>将 channel 的 <code>closed</code> 字段设置为 1，表示 channel 已经关闭。</p><ol start=6><li><strong>唤醒所有接收者</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>glist</span> <span style=color:#a6e22e>gList</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从接收队列中逐个取出等待的 goroutine，并执行以下操作：</p><ul><li>清除接收数据的内存位置。</li><li>记录当前时间（如果需要）。</li><li>设置 goroutine 的参数和状态。</li><li>如果启用了竞态检测，标记 goroutine 的状态。</li><li>将 goroutine 添加到 <code>glist</code> 列表中。</li></ul><ol start=7><li><strong>唤醒所有发送者</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从发送队列中逐个取出等待的 goroutine，并执行类似的操作。</p><ol start=8><li><strong>解锁</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span></code></pre></div><p>释放互斥锁。</p><ol start=9><li><strong>准备好所有 Goroutine</strong>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>遍历 <code>glist</code> 列表，将每个 goroutine 设置为就绪状态，以便它们可以继续执行。</p><h3 id=三小结>三、小结
<a class=header-anchor href=#%e4%b8%89%e5%b0%8f%e7%bb%93></a></h3><h4 id=31-有缓冲-channel-和无缓冲-channel-的对比>3.1 有缓冲 channel 和无缓冲 channel 的对比
<a class=header-anchor href=#31-%e6%9c%89%e7%bc%93%e5%86%b2-channel-%e5%92%8c%e6%97%a0%e7%bc%93%e5%86%b2-channel-%e7%9a%84%e5%af%b9%e6%af%94></a></h4><table><thead><tr><th>特性/操作</th><th>有缓冲的 channel</th><th>无缓冲的 channel</th></tr></thead><tbody><tr><td>缓冲区</td><td>包含一个固定大小的缓冲区，用作环形队列。</td><td>不包含缓冲区，<code>buf</code> 字段为 <code>nil</code>。</td></tr><tr><td>发送数据</td><td>数据被写入缓冲区的 <code>sendx</code> 位置，然后 <code>sendx</code> 索引增加并循环。</td><td>发送方 goroutine 被加入 <code>sendq</code> 队列，如果接收方不存在或不可立即接收则阻塞。</td></tr><tr><td>接收数据</td><td>从 <code>recvx</code> 位置读取数据，然后 <code>recvx</code> 索引增加并循环。当 <code>recvx</code> 与 <code>sendx</code> 相等时，表示缓冲区为空。</td><td>从 <code>sendq</code> 队列中取出等待的发送方 goroutine 并接收其数据，如果发送方不存在则阻塞。</td></tr><tr><td>同步性</td><td>异步传输数据，发送和接收操作不需要同时发生。</td><td>同步传输数据，发送和接收操作必须同时发生。</td></tr><tr><td>阻塞行为</td><td>发送方仅在缓冲区满时阻塞；接收方仅在缓冲区空时阻塞。</td><td>发送方在没有接收方时阻塞；接收方在没有发送方时阻塞。</td></tr><tr><td>使用场景</td><td>适用于生产者和消费者之间速率不匹配，需要缓冲区平滑处理的场景。</td><td>适用于需要确保发送和接收严格同步的场景，如信号量或事件通知。</td></tr><tr><td>性能特点</td><td>可以减少因同步等待导致的上下文切换，但可能会增加内存使用。</td><td>上下文切换可能更频繁，但不需要额外的缓冲区内存。</td></tr></tbody></table><h4 id=32-对-nil--已关闭的有数据的-channel-进行读写和关闭操作>3.2 对 nil / 已关闭的/有数据的 channel 进行读写和关闭操作
<a class=header-anchor href=#32-%e5%af%b9-nil--%e5%b7%b2%e5%85%b3%e9%97%ad%e7%9a%84%e6%9c%89%e6%95%b0%e6%8d%ae%e7%9a%84-channel-%e8%bf%9b%e8%a1%8c%e8%af%bb%e5%86%99%e5%92%8c%e5%85%b3%e9%97%ad%e6%93%8d%e4%bd%9c></a></h4><table><thead><tr><th>操作\Channel类型</th><th>Nil Channel</th><th>已关闭的 Channel</th><th>有数据的 Channel</th></tr></thead><tbody><tr><td>写入</td><td>panic</td><td>panic</td><td>成功（如果缓冲区未满）阻塞（如果缓冲区满）</td></tr><tr><td>读取</td><td>panic</td><td>可能成功（如果缓冲区有数据）返回零值（如果缓冲区空）</td><td>成功（如果缓冲区有数据）阻塞（如果缓冲区空且channel未关闭）返回零值（如果缓冲区空且channel已关闭）</td></tr><tr><td>关闭</td><td>panic</td><td>panic</td><td>成功（唤醒等待的goroutine）</td></tr></tbody></table><p>需要注意的是，对于已关闭的 channel，读取操作可能成功，这取决于缓冲区中是否还有数据。<br>对于有数据的 channel，关闭操作是安全的，并且会处理缓冲区中剩余的数据。</p><p>参考链接：</p><ol><li><a href=https://segmentfault.com/a/1190000042927699 title="从鹅厂实例出发！分析Go Channel底层原理" rel="noopener external nofollow noreferrer" target=_blank class=exturl>从鹅厂实例出发！分析Go Channel底层原理
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.cnblogs.com/killianxu/p/18286611 title="Golang channel底层是如何实现的?(深度好文) - golang架构师k哥 - 博客园" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Golang channel底层是如何实现的?(深度好文) - golang架构师k哥 - 博客园
<i class="fa fa-external-link-alt"></i></a></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/channel>channel
</a><a href=/tags/%e6%ba%90%e4%bb%a3%e7%a0%81>源代码</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/golang/list-sourcecode/ rel=next title=Golang的list和源码分析><i class="fa fa-chevron-left"></i> Golang的list和源码分析</a></div><div class="post-nav-prev post-nav-item"><a href=/post/db/lsm-tree-structure/ rel=prev title=LSM-tree的数据结构>LSM-tree的数据结构
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder></span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.139.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=//localhost:1313/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=//localhost:1313/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"//localhost:1313/3rd"}},"version":"4.6.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src=/js/main.js defer></script></body></html>